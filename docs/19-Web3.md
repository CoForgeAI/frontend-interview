# Web3 前端面试题

> Web3 前端开发涵盖区块链交互、钱包连接、智能合约调用、DApp 开发等核心技能。本章整理了 Web3 领域的高频面试题。

## 基础概念

### 1. 什么是 Web3？与 Web2 有什么区别？

**答案：**

| 对比 | Web2 | Web3 |
|------|------|------|
| 数据存储 | 中心化服务器 | 分布式区块链 |
| 账户系统 | 用户名/密码 | 钱包地址/私钥 |
| 数据所有权 | 平台所有 | 用户所有 |
| 信任模式 | 信任平台 | 信任代码（智能合约） |
| 支付方式 | 法币/第三方支付 | 加密货币 |
| 身份认证 | OAuth/JWT | 签名验证 |

**Web3 前端的核心职责：**

```javascript
// 1. 连接钱包
const provider = new ethers.BrowserProvider(window.ethereum);
const signer = await provider.getSigner();

// 2. 读取区块链数据
const balance = await provider.getBalance(address);

// 3. 发送交易
const tx = await signer.sendTransaction({
  to: recipient,
  value: ethers.parseEther("0.1")
});

// 4. 与智能合约交互
const contract = new ethers.Contract(address, abi, signer);
await contract.mint(tokenId);
```

---

### 2. 什么是以太坊？EVM 是什么？

**答案：**

**以太坊（Ethereum）：**
- 去中心化的智能合约平台
- 支持图灵完备的编程语言（Solidity）
- 使用 ETH 作为原生代币支付 Gas 费

**EVM（Ethereum Virtual Machine）：**
- 以太坊虚拟机，执行智能合约的运行环境
- 所有节点运行相同的 EVM，保证结果一致
- EVM 兼容链：BSC、Polygon、Avalanche、Arbitrum 等

```javascript
// 检测是否在 EVM 兼容链上
const chainId = await provider.getNetwork().then(n => n.chainId);

const EVMChains = {
  1: 'Ethereum Mainnet',
  56: 'BSC',
  137: 'Polygon',
  42161: 'Arbitrum',
  10: 'Optimism',
  43114: 'Avalanche'
};

console.log(`当前链: ${EVMChains[chainId] || 'Unknown'}`);
```

---

### 3. 什么是 Gas？Gas Price 和 Gas Limit 有什么区别？

**答案：**

**Gas：** 以太坊网络上执行操作的计算单位

**Gas Limit：** 愿意为交易支付的最大 Gas 数量
**Gas Price：** 每单位 Gas 的价格（单位：Gwei）
**交易费用 = Gas Used × Gas Price**

```javascript
// 估算 Gas
const gasEstimate = await contract.transfer.estimateGas(to, amount);

// 获取当前 Gas Price
const feeData = await provider.getFeeData();
console.log('Gas Price:', ethers.formatUnits(feeData.gasPrice, 'gwei'), 'Gwei');

// EIP-1559 交易（推荐）
const tx = await signer.sendTransaction({
  to: recipient,
  value: ethers.parseEther("0.1"),
  maxFeePerGas: feeData.maxFeePerGas,
  maxPriorityFeePerGas: feeData.maxPriorityFeePerGas
});

// 计算预估费用
const estimatedCost = gasEstimate * feeData.gasPrice;
console.log('预估费用:', ethers.formatEther(estimatedCost), 'ETH');
```

**Gas 优化技巧：**
- 选择网络空闲时间发送交易
- 使用 EIP-1559 交易类型
- 合并多笔交易（批量操作）

---

### 4. 什么是钱包地址和私钥？它们的关系是什么？

**答案：**

```
私钥 (Private Key)
    ↓ 椭圆曲线加密 (secp256k1)
公钥 (Public Key)
    ↓ Keccak-256 哈希 → 取后 20 字节
钱包地址 (Address)
```

**关键概念：**
- **私钥**：256 位随机数，必须保密，用于签名交易
- **公钥**：由私钥推导，可公开
- **地址**：由公钥推导，42 字符（0x + 40 位十六进制）

```javascript
// 生成新钱包
const wallet = ethers.Wallet.createRandom();
console.log('地址:', wallet.address);        // 0x...
console.log('私钥:', wallet.privateKey);      // 0x...（64 位十六进制）
console.log('助记词:', wallet.mnemonic.phrase); // 12/24 个单词

// 从私钥恢复钱包
const wallet2 = new ethers.Wallet(privateKey, provider);

// 从助记词恢复钱包
const wallet3 = ethers.Wallet.fromPhrase(mnemonic, provider);

// ⚠️ 永远不要在前端存储或暴露私钥！
```

---

### 5. 什么是智能合约？ABI 是什么？

**答案：**

**智能合约：**
- 部署在区块链上的程序代码
- 一旦部署，代码不可修改（可升级合约除外）
- 通过交易调用执行

**ABI（Application Binary Interface）：**
- 智能合约的接口描述
- 定义函数名、参数类型、返回值
- 前端与合约交互的桥梁

```javascript
// ABI 示例
const ERC20_ABI = [
  // 只读函数（view）
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function balanceOf(address owner) view returns (uint256)",

  // 写入函数
  "function transfer(address to, uint256 amount) returns (bool)",
  "function approve(address spender, uint256 amount) returns (bool)",

  // 事件
  "event Transfer(address indexed from, address indexed to, uint256 value)"
];

// 创建合约实例
const contract = new ethers.Contract(
  "0x...", // 合约地址
  ERC20_ABI,
  signer   // 或 provider（只读）
);

// 调用只读函数（不消耗 Gas）
const name = await contract.name();
const balance = await contract.balanceOf(address);

// 调用写入函数（需要 Gas）
const tx = await contract.transfer(to, amount);
await tx.wait(); // 等待交易确认
```

---

## 钱包连接

### 6. 如何连接 MetaMask 钱包？

**答案：**

```javascript
// 检测 MetaMask 是否安装
function isMetaMaskInstalled() {
  return typeof window.ethereum !== 'undefined' && window.ethereum.isMetaMask;
}

// 连接钱包
async function connectWallet() {
  if (!isMetaMaskInstalled()) {
    window.open('https://metamask.io/download/', '_blank');
    return;
  }

  try {
    // 请求连接
    const accounts = await window.ethereum.request({
      method: 'eth_requestAccounts'
    });

    const address = accounts[0];
    console.log('已连接:', address);

    // 获取链 ID
    const chainId = await window.ethereum.request({
      method: 'eth_chainId'
    });
    console.log('当前链:', parseInt(chainId, 16));

    return { address, chainId };
  } catch (error) {
    if (error.code === 4001) {
      console.log('用户拒绝连接');
    } else {
      console.error('连接失败:', error);
    }
  }
}

// 监听账户变化
window.ethereum.on('accountsChanged', (accounts) => {
  if (accounts.length === 0) {
    console.log('钱包已断开');
  } else {
    console.log('切换账户:', accounts[0]);
  }
});

// 监听链变化
window.ethereum.on('chainChanged', (chainId) => {
  console.log('切换网络:', parseInt(chainId, 16));
  // 推荐刷新页面
  window.location.reload();
});

// 断开连接（清除本地状态，MetaMask 需用户手动断开）
function disconnect() {
  // 清除本地存储的连接状态
  localStorage.removeItem('walletConnected');
  // 更新 UI 状态
  setAccount(null);
}
```

---

### 7. 什么是 WalletConnect？如何实现多钱包支持？

**答案：**

**WalletConnect：** 开放协议，通过扫码或深度链接连接移动端钱包

**推荐方案：使用 wagmi + RainbowKit / Web3Modal**

```javascript
// 使用 wagmi + RainbowKit
import { WagmiConfig, createConfig, configureChains, mainnet } from 'wagmi';
import { publicProvider } from 'wagmi/providers/public';
import { RainbowKitProvider, getDefaultWallets } from '@rainbow-me/rainbowkit';

// 配置链
const { chains, publicClient } = configureChains(
  [mainnet, polygon, arbitrum],
  [publicProvider()]
);

// 配置钱包
const { connectors } = getDefaultWallets({
  appName: 'My DApp',
  projectId: 'YOUR_PROJECT_ID', // WalletConnect Cloud
  chains
});

// 创建配置
const config = createConfig({
  autoConnect: true,
  connectors,
  publicClient
});

// 使用
function App() {
  return (
    <WagmiConfig config={config}>
      <RainbowKitProvider chains={chains}>
        <YourApp />
      </RainbowKitProvider>
    </WagmiConfig>
  );
}

// 在组件中使用
import { useAccount, useConnect, useDisconnect } from 'wagmi';
import { ConnectButton } from '@rainbow-me/rainbowkit';

function WalletButton() {
  const { address, isConnected } = useAccount();
  const { disconnect } = useDisconnect();

  // 方式 1：使用 RainbowKit 按钮
  return <ConnectButton />;

  // 方式 2：自定义 UI
  if (isConnected) {
    return (
      <div>
        <span>{address.slice(0, 6)}...{address.slice(-4)}</span>
        <button onClick={() => disconnect()}>断开</button>
      </div>
    );
  }

  return <ConnectButton />;
}
```

---

### 8. 如何切换网络（链）？

**答案：**

```javascript
// 切换到指定网络
async function switchNetwork(chainId) {
  try {
    await window.ethereum.request({
      method: 'wallet_switchEthereumChain',
      params: [{ chainId: `0x${chainId.toString(16)}` }]
    });
  } catch (error) {
    // 网络不存在，需要添加
    if (error.code === 4902) {
      await addNetwork(chainId);
    } else {
      throw error;
    }
  }
}

// 添加自定义网络
async function addNetwork(chainId) {
  const networks = {
    137: {
      chainId: '0x89',
      chainName: 'Polygon Mainnet',
      nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
      rpcUrls: ['https://polygon-rpc.com'],
      blockExplorerUrls: ['https://polygonscan.com']
    },
    56: {
      chainId: '0x38',
      chainName: 'BNB Smart Chain',
      nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
      rpcUrls: ['https://bsc-dataseed.binance.org'],
      blockExplorerUrls: ['https://bscscan.com']
    },
    42161: {
      chainId: '0xa4b1',
      chainName: 'Arbitrum One',
      nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
      rpcUrls: ['https://arb1.arbitrum.io/rpc'],
      blockExplorerUrls: ['https://arbiscan.io']
    }
  };

  await window.ethereum.request({
    method: 'wallet_addEthereumChain',
    params: [networks[chainId]]
  });
}

// 使用 wagmi
import { useSwitchNetwork } from 'wagmi';

function NetworkSwitcher() {
  const { switchNetwork, isLoading, pendingChainId } = useSwitchNetwork();

  return (
    <div>
      <button onClick={() => switchNetwork?.(1)}>
        Ethereum {isLoading && pendingChainId === 1 && '(切换中...)'}
      </button>
      <button onClick={() => switchNetwork?.(137)}>
        Polygon {isLoading && pendingChainId === 137 && '(切换中...)'}
      </button>
    </div>
  );
}
```

---

## 智能合约交互

### 9. ethers.js 和 web3.js 有什么区别？

**答案：**

| 对比 | ethers.js | web3.js |
|------|-----------|---------|
| 体积 | ~120KB（更轻量） | ~590KB |
| TypeScript | 原生支持 | 需要额外类型 |
| API 设计 | 现代、简洁 | 较传统 |
| Provider/Signer | 分离设计 | 耦合 |
| 大数处理 | 内置 BigInt | 需要 BN.js |
| 维护状态 | 活跃 | 较慢 |

**推荐使用 ethers.js v6：**

```javascript
// ethers.js v6
import { ethers } from 'ethers';

// Provider（只读）
const provider = new ethers.BrowserProvider(window.ethereum);

// Signer（可签名）
const signer = await provider.getSigner();

// 读取余额
const balance = await provider.getBalance(address);
console.log(ethers.formatEther(balance)); // 自动转换单位

// 合约交互
const contract = new ethers.Contract(address, abi, signer);
```

```javascript
// web3.js（对比）
import Web3 from 'web3';

const web3 = new Web3(window.ethereum);

// 读取余额
const balance = await web3.eth.getBalance(address);
console.log(web3.utils.fromWei(balance, 'ether'));

// 合约交互
const contract = new web3.eth.Contract(abi, address);
```

---

### 10. 如何调用智能合约的只读函数和写入函数？

**答案：**

```javascript
import { ethers } from 'ethers';

// ERC20 合约 ABI
const ERC20_ABI = [
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function totalSupply() view returns (uint256)",
  "function balanceOf(address) view returns (uint256)",
  "function transfer(address to, uint256 amount) returns (bool)",
  "function approve(address spender, uint256 amount) returns (bool)",
  "function allowance(address owner, address spender) view returns (uint256)",
  "event Transfer(address indexed from, address indexed to, uint256 value)",
  "event Approval(address indexed owner, address indexed spender, uint256 value)"
];

const USDT_ADDRESS = "0xdAC17F958D2ee523a2206206994597C13D831ec7";

// === 只读函数（view/pure）===
// 不需要 Gas，不需要签名，使用 Provider
async function readContract() {
  const provider = new ethers.JsonRpcProvider("https://eth.llamarpc.com");
  const contract = new ethers.Contract(USDT_ADDRESS, ERC20_ABI, provider);

  const name = await contract.name();
  const symbol = await contract.symbol();
  const decimals = await contract.decimals();
  const totalSupply = await contract.totalSupply();

  console.log(`${name} (${symbol})`);
  console.log(`Decimals: ${decimals}`);
  console.log(`Total Supply: ${ethers.formatUnits(totalSupply, decimals)}`);

  // 查询余额
  const balance = await contract.balanceOf("0x...");
  console.log(`Balance: ${ethers.formatUnits(balance, decimals)}`);
}

// === 写入函数 ===
// 需要 Gas，需要签名，使用 Signer
async function writeContract() {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const contract = new ethers.Contract(USDT_ADDRESS, ERC20_ABI, signer);

  // 转账
  const amount = ethers.parseUnits("100", 6); // USDT 是 6 位小数
  const tx = await contract.transfer("0x...", amount);

  console.log("交易哈希:", tx.hash);

  // 等待确认
  const receipt = await tx.wait();
  console.log("确认区块:", receipt.blockNumber);
  console.log("Gas 使用:", receipt.gasUsed.toString());

  // 授权
  const approveTx = await contract.approve("0xSpender...", ethers.MaxUint256);
  await approveTx.wait();
}

// === 错误处理 ===
async function safeContractCall() {
  try {
    const tx = await contract.transfer(to, amount);
    await tx.wait();
  } catch (error) {
    if (error.code === 'ACTION_REJECTED') {
      console.log('用户取消交易');
    } else if (error.code === 'INSUFFICIENT_FUNDS') {
      console.log('余额不足');
    } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
      console.log('合约执行会失败（可能是条件不满足）');
    } else {
      console.error('交易失败:', error.reason || error.message);
    }
  }
}
```

---

### 11. 如何监听合约事件？

**答案：**

```javascript
// 监听 Transfer 事件
const contract = new ethers.Contract(address, abi, provider);

// 方式 1：监听新事件（实时）
contract.on("Transfer", (from, to, value, event) => {
  console.log(`Transfer: ${from} -> ${to}, 数量: ${ethers.formatEther(value)}`);
  console.log(`交易哈希: ${event.log.transactionHash}`);
});

// 方式 2：监听特定条件的事件
const filter = contract.filters.Transfer(myAddress, null); // from = myAddress
contract.on(filter, (from, to, value) => {
  console.log(`从我的地址转出: ${ethers.formatEther(value)}`);
});

const filterTo = contract.filters.Transfer(null, myAddress); // to = myAddress
contract.on(filterTo, (from, to, value) => {
  console.log(`转入我的地址: ${ethers.formatEther(value)}`);
});

// 方式 3：查询历史事件
async function getHistoricalEvents() {
  const filter = contract.filters.Transfer();

  // 最近 1000 个区块的事件
  const currentBlock = await provider.getBlockNumber();
  const events = await contract.queryFilter(filter, currentBlock - 1000, currentBlock);

  events.forEach(event => {
    console.log(`Block ${event.blockNumber}: ${event.args.from} -> ${event.args.to}`);
  });
}

// 方式 4：使用 wagmi 的 useContractEvent
import { useContractEvent } from 'wagmi';

function TransferListener() {
  useContractEvent({
    address: '0x...',
    abi: ERC20_ABI,
    eventName: 'Transfer',
    listener(log) {
      console.log('Transfer event:', log);
    }
  });

  return <div>Listening for transfers...</div>;
}

// 停止监听
function cleanup() {
  contract.removeAllListeners("Transfer");
}
```

---

### 12. 如何处理交易状态和等待确认？

**答案：**

```javascript
async function sendTransaction() {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();

  // 状态：pending -> submitted -> confirmed/failed

  try {
    // 1. 发送交易（pending）
    console.log('等待用户确认...');
    const tx = await signer.sendTransaction({
      to: recipient,
      value: ethers.parseEther("0.1")
    });

    // 2. 交易已提交（submitted）
    console.log('交易已提交:', tx.hash);
    console.log('等待链上确认...');

    // 3. 等待确认
    const receipt = await tx.wait(1); // 等待 1 个确认

    // 4. 交易成功（confirmed）
    if (receipt.status === 1) {
      console.log('交易成功!');
      console.log('区块号:', receipt.blockNumber);
      console.log('Gas 使用:', receipt.gasUsed.toString());
    } else {
      // 交易失败（链上 revert）
      console.log('交易失败（合约执行失败）');
    }

    return receipt;
  } catch (error) {
    handleTransactionError(error);
  }
}

// 错误处理
function handleTransactionError(error) {
  switch (error.code) {
    case 'ACTION_REJECTED':
      console.log('用户拒绝签名');
      break;
    case 'INSUFFICIENT_FUNDS':
      console.log('余额不足（包括 Gas 费）');
      break;
    case 'NONCE_EXPIRED':
      console.log('Nonce 已使用，请重试');
      break;
    case 'REPLACEMENT_UNDERPRICED':
      console.log('Gas 价格太低，无法替换待处理交易');
      break;
    case 'TRANSACTION_REPLACED':
      if (error.cancelled) {
        console.log('交易被取消');
      } else {
        console.log('交易被替换，新交易:', error.replacement.hash);
      }
      break;
    default:
      console.error('交易错误:', error.message);
  }
}

// 等待多个确认（更安全）
async function waitForConfirmations(txHash, confirmations = 3) {
  const provider = new ethers.BrowserProvider(window.ethereum);

  console.log(`等待 ${confirmations} 个确认...`);

  const receipt = await provider.waitForTransaction(txHash, confirmations);

  console.log(`已确认 ${confirmations} 个区块`);
  return receipt;
}

// 轮询检查交易状态（备用方案）
async function pollTransactionStatus(txHash) {
  const provider = new ethers.BrowserProvider(window.ethereum);

  const checkStatus = async () => {
    const receipt = await provider.getTransactionReceipt(txHash);

    if (receipt === null) {
      console.log('交易待处理...');
      return 'pending';
    }

    if (receipt.status === 1) {
      console.log('交易成功');
      return 'success';
    } else {
      console.log('交易失败');
      return 'failed';
    }
  };

  // 每 3 秒检查一次
  return new Promise((resolve) => {
    const interval = setInterval(async () => {
      const status = await checkStatus();
      if (status !== 'pending') {
        clearInterval(interval);
        resolve(status);
      }
    }, 3000);
  });
}
```

---

## NFT 开发

### 13. ERC-721 和 ERC-1155 有什么区别？

**答案：**

| 特性 | ERC-721 | ERC-1155 |
|------|---------|----------|
| 代币类型 | 非同质化（每个唯一） | 同质化 + 非同质化 |
| 转账效率 | 每次一个 NFT | 批量转账 |
| Gas 费用 | 较高 | 较低（批量操作） |
| 元数据 | 每个 Token 独立 URI | 可共享 URI 模板 |
| 适用场景 | 头像 NFT、艺术品 | 游戏道具、门票 |

```javascript
// ERC-721 ABI
const ERC721_ABI = [
  "function balanceOf(address owner) view returns (uint256)",
  "function ownerOf(uint256 tokenId) view returns (address)",
  "function tokenURI(uint256 tokenId) view returns (string)",
  "function approve(address to, uint256 tokenId)",
  "function setApprovalForAll(address operator, bool approved)",
  "function transferFrom(address from, address to, uint256 tokenId)",
  "function safeTransferFrom(address from, address to, uint256 tokenId)",
  "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)"
];

// ERC-1155 ABI
const ERC1155_ABI = [
  "function balanceOf(address account, uint256 id) view returns (uint256)",
  "function balanceOfBatch(address[] accounts, uint256[] ids) view returns (uint256[])",
  "function uri(uint256 id) view returns (string)",
  "function setApprovalForAll(address operator, bool approved)",
  "function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data)",
  "function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data)",
  "event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)",
  "event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)"
];

// 查询 NFT
async function getNFTInfo(contractAddress, tokenId) {
  const contract = new ethers.Contract(contractAddress, ERC721_ABI, provider);

  const owner = await contract.ownerOf(tokenId);
  const tokenURI = await contract.tokenURI(tokenId);

  // 获取元数据
  let metadata;
  if (tokenURI.startsWith('ipfs://')) {
    const ipfsGateway = 'https://ipfs.io/ipfs/';
    const httpURI = tokenURI.replace('ipfs://', ipfsGateway);
    const response = await fetch(httpURI);
    metadata = await response.json();
  } else {
    const response = await fetch(tokenURI);
    metadata = await response.json();
  }

  return { owner, tokenURI, metadata };
}
```

---

### 14. 如何实现 NFT Mint 功能？

**答案：**

```javascript
// NFT 合约 ABI（假设有 mint 函数）
const NFT_ABI = [
  "function mint(uint256 quantity) payable",
  "function totalSupply() view returns (uint256)",
  "function maxSupply() view returns (uint256)",
  "function mintPrice() view returns (uint256)",
  "function balanceOf(address) view returns (uint256)"
];

async function mintNFT(quantity = 1) {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const contract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, signer);

  // 获取 mint 价格
  const mintPrice = await contract.mintPrice();
  const totalCost = mintPrice * BigInt(quantity);

  console.log(`Mint ${quantity} 个 NFT`);
  console.log(`单价: ${ethers.formatEther(mintPrice)} ETH`);
  console.log(`总价: ${ethers.formatEther(totalCost)} ETH`);

  // 检查剩余数量
  const totalSupply = await contract.totalSupply();
  const maxSupply = await contract.maxSupply();
  const remaining = maxSupply - totalSupply;

  if (remaining < quantity) {
    throw new Error(`只剩 ${remaining} 个可 mint`);
  }

  // 发送 mint 交易
  const tx = await contract.mint(quantity, {
    value: totalCost
  });

  console.log('交易已提交:', tx.hash);

  // 等待确认
  const receipt = await tx.wait();

  // 从事件中获取 mint 的 tokenId
  const transferEvents = receipt.logs
    .filter(log => log.address.toLowerCase() === NFT_ADDRESS.toLowerCase())
    .map(log => contract.interface.parseLog(log))
    .filter(parsed => parsed?.name === 'Transfer');

  const mintedTokenIds = transferEvents.map(e => e.args.tokenId.toString());

  console.log('Mint 成功! Token IDs:', mintedTokenIds);

  return { receipt, tokenIds: mintedTokenIds };
}

// React 组件示例
function MintButton() {
  const [quantity, setQuantity] = useState(1);
  const [loading, setLoading] = useState(false);
  const [txHash, setTxHash] = useState(null);

  const handleMint = async () => {
    setLoading(true);
    try {
      const { receipt, tokenIds } = await mintNFT(quantity);
      setTxHash(receipt.hash);
      alert(`成功 mint ${tokenIds.length} 个 NFT!`);
    } catch (error) {
      if (error.code === 'ACTION_REJECTED') {
        alert('用户取消交易');
      } else {
        alert(`Mint 失败: ${error.message}`);
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <input
        type="number"
        min="1"
        max="10"
        value={quantity}
        onChange={(e) => setQuantity(parseInt(e.target.value))}
      />
      <button onClick={handleMint} disabled={loading}>
        {loading ? 'Minting...' : `Mint ${quantity} NFT`}
      </button>
      {txHash && (
        <a
          href={`https://etherscan.io/tx/${txHash}`}
          target="_blank"
          rel="noopener noreferrer"
        >
          查看交易
        </a>
      )}
    </div>
  );
}
```

---

### 15. 如何获取用户持有的 NFT 列表？

**答案：**

```javascript
// 方式 1：使用 Alchemy/Moralis API（推荐）
async function getNFTsFromAlchemy(ownerAddress) {
  const apiKey = 'YOUR_ALCHEMY_API_KEY';
  const baseURL = `https://eth-mainnet.g.alchemy.com/nft/v3/${apiKey}`;

  const response = await fetch(
    `${baseURL}/getNFTsForOwner?owner=${ownerAddress}&withMetadata=true`
  );

  const data = await response.json();

  return data.ownedNfts.map(nft => ({
    contractAddress: nft.contract.address,
    tokenId: nft.tokenId,
    name: nft.name,
    description: nft.description,
    image: nft.image?.cachedUrl || nft.image?.originalUrl,
    collection: nft.contract.name
  }));
}

// 方式 2：查询特定集合的 NFT
async function getNFTsFromContract(contractAddress, ownerAddress) {
  const contract = new ethers.Contract(contractAddress, ERC721_ABI, provider);

  // 获取用户持有数量
  const balance = await contract.balanceOf(ownerAddress);
  const tokenIds = [];

  // 如果合约支持 tokenOfOwnerByIndex（ERC721Enumerable）
  if (contract.tokenOfOwnerByIndex) {
    for (let i = 0; i < balance; i++) {
      const tokenId = await contract.tokenOfOwnerByIndex(ownerAddress, i);
      tokenIds.push(tokenId.toString());
    }
  } else {
    // 从 Transfer 事件中获取
    const filter = contract.filters.Transfer(null, ownerAddress);
    const events = await contract.queryFilter(filter, 0, 'latest');

    for (const event of events) {
      const tokenId = event.args.tokenId.toString();
      // 验证当前所有者
      const currentOwner = await contract.ownerOf(tokenId);
      if (currentOwner.toLowerCase() === ownerAddress.toLowerCase()) {
        tokenIds.push(tokenId);
      }
    }
  }

  // 获取元数据
  const nfts = await Promise.all(
    tokenIds.map(async (tokenId) => {
      const tokenURI = await contract.tokenURI(tokenId);
      const metadata = await fetchMetadata(tokenURI);
      return { tokenId, ...metadata };
    })
  );

  return nfts;
}

// 获取元数据
async function fetchMetadata(tokenURI) {
  // 处理 IPFS URI
  let url = tokenURI;
  if (tokenURI.startsWith('ipfs://')) {
    url = tokenURI.replace('ipfs://', 'https://ipfs.io/ipfs/');
  }

  // 处理 Base64 编码的元数据
  if (tokenURI.startsWith('data:application/json;base64,')) {
    const base64 = tokenURI.replace('data:application/json;base64,', '');
    return JSON.parse(atob(base64));
  }

  const response = await fetch(url);
  return response.json();
}

// 方式 3：使用 The Graph 查询
const SUBGRAPH_URL = 'https://api.thegraph.com/subgraphs/name/...';

async function getNFTsFromGraph(ownerAddress) {
  const query = `
    query GetNFTs($owner: String!) {
      tokens(where: { owner: $owner }) {
        id
        tokenId
        tokenURI
        owner {
          id
        }
      }
    }
  `;

  const response = await fetch(SUBGRAPH_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      query,
      variables: { owner: ownerAddress.toLowerCase() }
    })
  });

  const { data } = await response.json();
  return data.tokens;
}
```

---

## DeFi 相关

### 16. 什么是 ERC-20？如何实现代币转账和授权？

**答案：**

**ERC-20：** 同质化代币标准，定义了代币的基本功能

```javascript
const ERC20_ABI = [
  // 查询函数
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function totalSupply() view returns (uint256)",
  "function balanceOf(address account) view returns (uint256)",
  "function allowance(address owner, address spender) view returns (uint256)",

  // 写入函数
  "function transfer(address to, uint256 amount) returns (bool)",
  "function approve(address spender, uint256 amount) returns (bool)",
  "function transferFrom(address from, address to, uint256 amount) returns (bool)",

  // 事件
  "event Transfer(address indexed from, address indexed to, uint256 value)",
  "event Approval(address indexed owner, address indexed spender, uint256 value)"
];

// 代币转账
async function transferToken(tokenAddress, to, amount) {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const contract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);

  // 获取代币精度
  const decimals = await contract.decimals();

  // 转换金额
  const amountInWei = ethers.parseUnits(amount.toString(), decimals);

  // 检查余额
  const balance = await contract.balanceOf(await signer.getAddress());
  if (balance < amountInWei) {
    throw new Error('余额不足');
  }

  // 发送交易
  const tx = await contract.transfer(to, amountInWei);
  const receipt = await tx.wait();

  return receipt;
}

// 授权（Approve）
async function approveToken(tokenAddress, spender, amount) {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const contract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);

  const decimals = await contract.decimals();

  // 无限授权（常见做法，但有安全风险）
  // const amountInWei = ethers.MaxUint256;

  // 精确授权（更安全）
  const amountInWei = ethers.parseUnits(amount.toString(), decimals);

  const tx = await contract.approve(spender, amountInWei);
  const receipt = await tx.wait();

  return receipt;
}

// 检查授权额度
async function checkAllowance(tokenAddress, owner, spender) {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const contract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);

  const decimals = await contract.decimals();
  const allowance = await contract.allowance(owner, spender);

  return ethers.formatUnits(allowance, decimals);
}

// 完整的 Swap 流程示例
async function swapTokens(tokenIn, tokenOut, amountIn, routerAddress) {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const userAddress = await signer.getAddress();

  // 1. 检查授权
  const allowance = await checkAllowance(tokenIn, userAddress, routerAddress);

  if (parseFloat(allowance) < parseFloat(amountIn)) {
    // 2. 授权
    console.log('正在授权...');
    await approveToken(tokenIn, routerAddress, amountIn);
    console.log('授权成功');
  }

  // 3. 执行 Swap
  const router = new ethers.Contract(routerAddress, ROUTER_ABI, signer);

  const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20 分钟后过期

  const tx = await router.swapExactTokensForTokens(
    amountIn,
    0, // amountOutMin（实际应该计算滑点）
    [tokenIn, tokenOut],
    userAddress,
    deadline
  );

  return tx.wait();
}
```

---

### 17. 什么是 Permit（EIP-2612）？与传统 Approve 有什么区别？

**答案：**

**传统 Approve：** 需要两笔交易（approve + swap），用户支付两次 Gas

**Permit（EIP-2612）：** 使用签名授权，只需一笔交易

```javascript
// Permit 签名
async function createPermitSignature(
  tokenAddress,
  spender,
  amount,
  deadline
) {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const owner = await signer.getAddress();

  // 获取代币信息
  const token = new ethers.Contract(tokenAddress, [
    "function name() view returns (string)",
    "function nonces(address) view returns (uint256)",
    "function DOMAIN_SEPARATOR() view returns (bytes32)"
  ], provider);

  const [name, nonce, domainSeparator] = await Promise.all([
    token.name(),
    token.nonces(owner),
    token.DOMAIN_SEPARATOR()
  ]);

  // EIP-712 类型定义
  const domain = {
    name,
    version: '1',
    chainId: (await provider.getNetwork()).chainId,
    verifyingContract: tokenAddress
  };

  const types = {
    Permit: [
      { name: 'owner', type: 'address' },
      { name: 'spender', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'nonce', type: 'uint256' },
      { name: 'deadline', type: 'uint256' }
    ]
  };

  const value = {
    owner,
    spender,
    value: amount,
    nonce,
    deadline
  };

  // 签名
  const signature = await signer.signTypedData(domain, types, value);
  const { v, r, s } = ethers.Signature.from(signature);

  return { v, r, s, deadline, nonce };
}

// 使用 Permit 进行 Swap（一笔交易）
async function swapWithPermit(
  tokenIn,
  tokenOut,
  amountIn,
  routerAddress
) {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();

  const deadline = Math.floor(Date.now() / 1000) + 60 * 20;

  // 创建 Permit 签名
  const { v, r, s } = await createPermitSignature(
    tokenIn,
    routerAddress,
    amountIn,
    deadline
  );

  // 调用支持 Permit 的 Swap 函数
  const router = new ethers.Contract(routerAddress, [
    "function swapWithPermit(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOutMin, uint256 deadline, uint8 v, bytes32 r, bytes32 s)"
  ], signer);

  const tx = await router.swapWithPermit(
    tokenIn,
    tokenOut,
    amountIn,
    0, // amountOutMin
    deadline,
    v, r, s
  );

  return tx.wait();
}
```

**Permit2（Uniswap）：** 更高级的授权方案，一次授权多个协议

```javascript
// Permit2 地址（所有链相同）
const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3';

// 1. 首先授权给 Permit2（只需一次）
await approveToken(tokenAddress, PERMIT2_ADDRESS, ethers.MaxUint256);

// 2. 然后用 Permit2 签名授权给具体协议（无需 Gas）
// ...
```

---

### 18. 如何集成 Uniswap 实现代币兑换？

**答案：**

```javascript
import { ethers } from 'ethers';

// Uniswap V3 Router 地址
const SWAP_ROUTER_ADDRESS = '0xE592427A0AEce92De3Edee1F18E0157C05861564';

// Uniswap V3 Quoter 地址（获取报价）
const QUOTER_ADDRESS = '0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6';

// Router ABI
const SWAP_ROUTER_ABI = [
  "function exactInputSingle((address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 deadline, uint256 amountIn, uint256 amountOutMinimum, uint160 sqrtPriceLimitX96)) external payable returns (uint256 amountOut)"
];

// Quoter ABI
const QUOTER_ABI = [
  "function quoteExactInputSingle(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn, uint160 sqrtPriceLimitX96) external returns (uint256 amountOut)"
];

// 获取报价
async function getQuote(tokenIn, tokenOut, amountIn, fee = 3000) {
  const provider = new ethers.JsonRpcProvider("https://eth.llamarpc.com");
  const quoter = new ethers.Contract(QUOTER_ADDRESS, QUOTER_ABI, provider);

  // 使用 staticCall 模拟调用
  const amountOut = await quoter.quoteExactInputSingle.staticCall(
    tokenIn,
    tokenOut,
    fee,
    amountIn,
    0
  );

  return amountOut;
}

// 执行 Swap
async function swap(tokenIn, tokenOut, amountIn, slippage = 0.5) {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const userAddress = await signer.getAddress();

  // 1. 获取报价
  const amountOutQuote = await getQuote(tokenIn, tokenOut, amountIn);

  // 2. 计算最小接收数量（考虑滑点）
  const amountOutMinimum = amountOutQuote * BigInt(1000 - slippage * 10) / BigInt(1000);

  // 3. 检查并授权
  const tokenContract = new ethers.Contract(tokenIn, ERC20_ABI, signer);
  const allowance = await tokenContract.allowance(userAddress, SWAP_ROUTER_ADDRESS);

  if (allowance < amountIn) {
    const approveTx = await tokenContract.approve(SWAP_ROUTER_ADDRESS, amountIn);
    await approveTx.wait();
  }

  // 4. 执行 Swap
  const router = new ethers.Contract(SWAP_ROUTER_ADDRESS, SWAP_ROUTER_ABI, signer);

  const params = {
    tokenIn,
    tokenOut,
    fee: 3000, // 0.3%
    recipient: userAddress,
    deadline: Math.floor(Date.now() / 1000) + 60 * 20,
    amountIn,
    amountOutMinimum,
    sqrtPriceLimitX96: 0
  };

  const tx = await router.exactInputSingle(params);
  const receipt = await tx.wait();

  return receipt;
}

// 使用 Uniswap SDK（推荐）
import { Token, CurrencyAmount, TradeType, Percent } from '@uniswap/sdk-core';
import { Pool, Route, Trade, SwapRouter } from '@uniswap/v3-sdk';

async function swapWithSDK() {
  // 定义代币
  const WETH = new Token(1, '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', 18, 'WETH');
  const USDC = new Token(1, '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', 6, 'USDC');

  // 获取 Pool 数据（从链上或 API）
  // ...

  // 创建交易
  const trade = Trade.createUncheckedTrade({
    route: new Route([pool], WETH, USDC),
    inputAmount: CurrencyAmount.fromRawAmount(WETH, amountIn),
    outputAmount: CurrencyAmount.fromRawAmount(USDC, amountOut),
    tradeType: TradeType.EXACT_INPUT
  });

  // 生成交易数据
  const { calldata, value } = SwapRouter.swapCallParameters(trade, {
    slippageTolerance: new Percent(50, 10000), // 0.5%
    recipient: userAddress,
    deadline: Math.floor(Date.now() / 1000) + 60 * 20
  });

  // 发送交易
  const tx = await signer.sendTransaction({
    to: SWAP_ROUTER_ADDRESS,
    data: calldata,
    value
  });

  return tx.wait();
}
```

---

## 签名与验证

### 19. 什么是消息签名？如何实现签名登录？

**答案：**

**签名登录流程：**
1. 前端请求 nonce（随机数）
2. 用户签名包含 nonce 的消息
3. 后端验证签名，返回 JWT

```javascript
// 前端签名
async function signMessage(message) {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();

  // 签名消息
  const signature = await signer.signMessage(message);

  return {
    address: await signer.getAddress(),
    message,
    signature
  };
}

// 签名登录
async function signIn() {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const address = await signer.getAddress();

  // 1. 从后端获取 nonce
  const { nonce } = await fetch(`/api/auth/nonce?address=${address}`).then(r => r.json());

  // 2. 构造签名消息
  const message = `Welcome to MyDApp!\n\nPlease sign this message to verify your wallet.\n\nNonce: ${nonce}\nTimestamp: ${Date.now()}`;

  // 3. 签名
  const signature = await signer.signMessage(message);

  // 4. 发送到后端验证
  const { token } = await fetch('/api/auth/verify', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ address, message, signature })
  }).then(r => r.json());

  // 5. 存储 JWT
  localStorage.setItem('token', token);

  return token;
}

// 后端验证（Node.js）
const { ethers } = require('ethers');

async function verifySignature(address, message, signature) {
  // 从签名恢复地址
  const recoveredAddress = ethers.verifyMessage(message, signature);

  // 验证地址匹配
  if (recoveredAddress.toLowerCase() !== address.toLowerCase()) {
    throw new Error('Invalid signature');
  }

  // 验证 nonce（防止重放攻击）
  const nonceMatch = message.match(/Nonce: (\w+)/);
  if (!nonceMatch) {
    throw new Error('Invalid message format');
  }

  const nonce = nonceMatch[1];
  const storedNonce = await getNonceFromDB(address);

  if (nonce !== storedNonce) {
    throw new Error('Invalid nonce');
  }

  // 更新 nonce（一次性使用）
  await updateNonce(address);

  return true;
}

// 使用 SIWE（Sign-In with Ethereum）标准
import { SiweMessage } from 'siwe';

async function signInWithEthereum() {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const address = await signer.getAddress();
  const chainId = (await provider.getNetwork()).chainId;

  // 创建 SIWE 消息
  const siweMessage = new SiweMessage({
    domain: window.location.host,
    address,
    statement: 'Sign in with Ethereum to MyDApp',
    uri: window.location.origin,
    version: '1',
    chainId: Number(chainId),
    nonce: generateNonce(), // 随机 nonce
    issuedAt: new Date().toISOString()
  });

  const message = siweMessage.prepareMessage();
  const signature = await signer.signMessage(message);

  // 发送到后端验证
  const response = await fetch('/api/auth/siwe', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ message, signature })
  });

  return response.json();
}
```

---

### 20. 什么是 EIP-712 类型化签名？

**答案：**

**EIP-712：** 结构化数据签名标准，显示清晰的签名内容，防止钓鱼

```javascript
// EIP-712 签名示例（NFT 白名单）
async function signWhitelist(userAddress, tokenId) {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();

  // 域信息
  const domain = {
    name: 'MyNFT',
    version: '1',
    chainId: 1,
    verifyingContract: '0x...' // NFT 合约地址
  };

  // 类型定义
  const types = {
    Whitelist: [
      { name: 'user', type: 'address' },
      { name: 'tokenId', type: 'uint256' },
      { name: 'deadline', type: 'uint256' }
    ]
  };

  // 数据
  const value = {
    user: userAddress,
    tokenId,
    deadline: Math.floor(Date.now() / 1000) + 60 * 60 * 24 // 24小时后过期
  };

  // 签名
  const signature = await signer.signTypedData(domain, types, value);

  return { signature, deadline: value.deadline };
}

// NFT 合约中验证签名
/*
function mintWithSignature(
    uint256 tokenId,
    uint256 deadline,
    bytes calldata signature
) external {
    require(block.timestamp <= deadline, "Signature expired");

    bytes32 structHash = keccak256(
        abi.encode(
            WHITELIST_TYPEHASH,
            msg.sender,
            tokenId,
            deadline
        )
    );

    bytes32 hash = _hashTypedDataV4(structHash);
    address signer = ECDSA.recover(hash, signature);

    require(signer == whitelistSigner, "Invalid signature");

    _mint(msg.sender, tokenId);
}
*/

// 订单签名（OpenSea Seaport 风格）
async function signOrder(order) {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();

  const domain = {
    name: 'Seaport',
    version: '1.5',
    chainId: 1,
    verifyingContract: '0x00000000000000ADc04C56Bf30aC9d3c0aAF14dC'
  };

  const types = {
    OrderComponents: [
      { name: 'offerer', type: 'address' },
      { name: 'zone', type: 'address' },
      { name: 'offer', type: 'OfferItem[]' },
      { name: 'consideration', type: 'ConsiderationItem[]' },
      { name: 'orderType', type: 'uint8' },
      { name: 'startTime', type: 'uint256' },
      { name: 'endTime', type: 'uint256' },
      { name: 'zoneHash', type: 'bytes32' },
      { name: 'salt', type: 'uint256' },
      { name: 'conduitKey', type: 'bytes32' },
      { name: 'counter', type: 'uint256' }
    ],
    OfferItem: [
      { name: 'itemType', type: 'uint8' },
      { name: 'token', type: 'address' },
      { name: 'identifierOrCriteria', type: 'uint256' },
      { name: 'startAmount', type: 'uint256' },
      { name: 'endAmount', type: 'uint256' }
    ],
    ConsiderationItem: [
      { name: 'itemType', type: 'uint8' },
      { name: 'token', type: 'address' },
      { name: 'identifierOrCriteria', type: 'uint256' },
      { name: 'startAmount', type: 'uint256' },
      { name: 'endAmount', type: 'uint256' },
      { name: 'recipient', type: 'address' }
    ]
  };

  const signature = await signer.signTypedData(domain, types, order);

  return signature;
}
```

---

## 多链与 Layer2

### 21. 什么是 Layer2？主要的 L2 方案有哪些？

**答案：**

**Layer2：** 在以太坊主网（L1）之上的扩容方案，提高吞吐量、降低费用

| L2 方案 | 类型 | 特点 | 代表项目 |
|---------|------|------|----------|
| Optimistic Rollup | 欺诈证明 | 兼容 EVM、提款需等待 | Optimism, Arbitrum |
| ZK Rollup | 有效性证明 | 更安全、即时确认 | zkSync, StarkNet, Polygon zkEVM |
| Validium | 链下数据 | 更便宜、数据可用性依赖方 | StarkEx |
| Plasma | 子链 | 已较少使用 | - |

```javascript
// 检测和切换 L2 网络
const L2_NETWORKS = {
  // Arbitrum One
  42161: {
    chainId: '0xa4b1',
    chainName: 'Arbitrum One',
    nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
    rpcUrls: ['https://arb1.arbitrum.io/rpc'],
    blockExplorerUrls: ['https://arbiscan.io']
  },
  // Optimism
  10: {
    chainId: '0xa',
    chainName: 'Optimism',
    nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
    rpcUrls: ['https://mainnet.optimism.io'],
    blockExplorerUrls: ['https://optimistic.etherscan.io']
  },
  // Base
  8453: {
    chainId: '0x2105',
    chainName: 'Base',
    nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
    rpcUrls: ['https://mainnet.base.org'],
    blockExplorerUrls: ['https://basescan.org']
  },
  // zkSync Era
  324: {
    chainId: '0x144',
    chainName: 'zkSync Era',
    nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
    rpcUrls: ['https://mainnet.era.zksync.io'],
    blockExplorerUrls: ['https://explorer.zksync.io']
  }
};

// 切换到 L2
async function switchToL2(chainId) {
  try {
    await window.ethereum.request({
      method: 'wallet_switchEthereumChain',
      params: [{ chainId: L2_NETWORKS[chainId].chainId }]
    });
  } catch (error) {
    if (error.code === 4902) {
      await window.ethereum.request({
        method: 'wallet_addEthereumChain',
        params: [L2_NETWORKS[chainId]]
      });
    }
  }
}

// 多链 Provider
function getProvider(chainId) {
  const rpcUrls = {
    1: 'https://eth.llamarpc.com',
    42161: 'https://arb1.arbitrum.io/rpc',
    10: 'https://mainnet.optimism.io',
    137: 'https://polygon-rpc.com'
  };

  return new ethers.JsonRpcProvider(rpcUrls[chainId]);
}

// 查询多链余额
async function getMultiChainBalance(address) {
  const chains = [1, 42161, 10, 137];
  const balances = await Promise.all(
    chains.map(async (chainId) => {
      const provider = getProvider(chainId);
      const balance = await provider.getBalance(address);
      return {
        chainId,
        balance: ethers.formatEther(balance)
      };
    })
  );
  return balances;
}
```

---

### 22. 如何实现跨链桥交互？

**答案：**

```javascript
// 使用官方桥（以 Arbitrum 为例）
// Arbitrum Gateway Router
const GATEWAY_ROUTER = '0x72Ce9c846789fdB6fC1f34aC4AD25Dd9ef7031ef';

const GATEWAY_ABI = [
  "function outboundTransfer(address _token, address _to, uint256 _amount, uint256 _maxGas, uint256 _gasPriceBid, bytes _data) payable returns (bytes)"
];

// L1 -> L2 存款
async function depositToArbitrum(tokenAddress, amount) {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();

  // 1. 授权 Gateway
  const token = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
  const gateway = await getGatewayAddress(tokenAddress); // 获取对应的 Gateway

  await token.approve(gateway, amount);

  // 2. 调用 outboundTransfer
  const router = new ethers.Contract(GATEWAY_ROUTER, GATEWAY_ABI, signer);

  const tx = await router.outboundTransfer(
    tokenAddress,
    await signer.getAddress(),
    amount,
    0, // maxGas
    0, // gasPriceBid
    '0x', // data
    { value: ethers.parseEther('0.01') } // ETH 用于 L2 gas
  );

  return tx.wait();
}

// 使用聚合桥（Socket/LI.FI）
async function bridgeWithSocket(params) {
  const {
    fromChainId,
    toChainId,
    fromTokenAddress,
    toTokenAddress,
    fromAmount,
    userAddress
  } = params;

  // 1. 获取报价
  const quoteUrl = `https://api.socket.tech/v2/quote?fromChainId=${fromChainId}&toChainId=${toChainId}&fromTokenAddress=${fromTokenAddress}&toTokenAddress=${toTokenAddress}&fromAmount=${fromAmount}&userAddress=${userAddress}&sort=output`;

  const quoteResponse = await fetch(quoteUrl, {
    headers: { 'API-KEY': 'YOUR_SOCKET_API_KEY' }
  });

  const { result } = await quoteResponse.json();
  const route = result.routes[0]; // 选择最优路由

  // 2. 获取交易数据
  const buildUrl = 'https://api.socket.tech/v2/build-tx';
  const buildResponse = await fetch(buildUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'API-KEY': 'YOUR_SOCKET_API_KEY'
    },
    body: JSON.stringify({ route })
  });

  const { result: txData } = await buildResponse.json();

  // 3. 执行交易
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();

  // 如果需要授权
  if (txData.approvalData) {
    const approveTx = await signer.sendTransaction({
      to: txData.approvalData.approvalTokenAddress,
      data: txData.approvalData.data
    });
    await approveTx.wait();
  }

  // 执行桥接
  const bridgeTx = await signer.sendTransaction({
    to: txData.txTarget,
    data: txData.txData,
    value: txData.value
  });

  return bridgeTx.wait();
}
```

---

## IPFS 与存储

### 23. 什么是 IPFS？如何在 DApp 中使用？

**答案：**

**IPFS（InterPlanetary File System）：** 去中心化的分布式文件存储系统

- **内容寻址**：通过文件哈希（CID）而非位置访问
- **去中心化**：文件分布在多个节点
- **永久存储**：配合 Filecoin/Arweave 实现

```javascript
// 使用 Pinata 上传到 IPFS
async function uploadToIPFS(file) {
  const formData = new FormData();
  formData.append('file', file);

  const response = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${PINATA_JWT}`
    },
    body: formData
  });

  const { IpfsHash } = await response.json();

  return {
    cid: IpfsHash,
    url: `ipfs://${IpfsHash}`,
    gateway: `https://gateway.pinata.cloud/ipfs/${IpfsHash}`
  };
}

// 上传 JSON 元数据
async function uploadMetadata(metadata) {
  const response = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${PINATA_JWT}`
    },
    body: JSON.stringify({
      pinataContent: metadata,
      pinataMetadata: {
        name: metadata.name
      }
    })
  });

  const { IpfsHash } = await response.json();
  return `ipfs://${IpfsHash}`;
}

// NFT 元数据上传完整流程
async function uploadNFTMetadata(imageFile, nftData) {
  // 1. 上传图片
  const imageResult = await uploadToIPFS(imageFile);

  // 2. 创建元数据
  const metadata = {
    name: nftData.name,
    description: nftData.description,
    image: imageResult.url, // ipfs://...
    attributes: nftData.attributes || []
  };

  // 3. 上传元数据
  const metadataURI = await uploadMetadata(metadata);

  return metadataURI;
}

// 从 IPFS 获取数据
async function fetchFromIPFS(cid) {
  // 使用公共网关
  const gateways = [
    `https://ipfs.io/ipfs/${cid}`,
    `https://gateway.pinata.cloud/ipfs/${cid}`,
    `https://cloudflare-ipfs.com/ipfs/${cid}`,
    `https://dweb.link/ipfs/${cid}`
  ];

  // 尝试多个网关
  for (const gateway of gateways) {
    try {
      const response = await fetch(gateway, { timeout: 10000 });
      if (response.ok) {
        return response;
      }
    } catch (error) {
      continue;
    }
  }

  throw new Error('Failed to fetch from IPFS');
}

// 转换 IPFS URI 到 HTTP URL
function ipfsToHttp(ipfsUri) {
  if (!ipfsUri) return null;

  if (ipfsUri.startsWith('ipfs://')) {
    const cid = ipfsUri.replace('ipfs://', '');
    return `https://ipfs.io/ipfs/${cid}`;
  }

  if (ipfsUri.startsWith('ar://')) {
    const id = ipfsUri.replace('ar://', '');
    return `https://arweave.net/${id}`;
  }

  return ipfsUri;
}
```

---

## 安全与最佳实践

### 24. Web3 前端有哪些常见的安全问题？

**答案：**

**1. 私钥泄露**

```javascript
// ❌ 错误：在前端存储私钥
localStorage.setItem('privateKey', privateKey);

// ✅ 正确：只存储公开信息
localStorage.setItem('walletAddress', address);
localStorage.setItem('isConnected', 'true');
```

**2. 签名钓鱼**

```javascript
// ❌ 危险：签名前不展示内容
const signature = await signer.signMessage(message);

// ✅ 安全：清晰展示签名内容
const displayMessage = `
  您正在签名的内容：
  ${message}

  请确认这是您期望的操作。
`;
if (confirm(displayMessage)) {
  const signature = await signer.signMessage(message);
}

// ✅ 使用 EIP-712 结构化签名（MetaMask 会清晰展示）
const signature = await signer.signTypedData(domain, types, value);
```

**3. 无限授权风险**

```javascript
// ❌ 危险：无限授权
await token.approve(spender, ethers.MaxUint256);

// ✅ 更安全：精确授权
await token.approve(spender, exactAmount);

// ✅ 使用后撤销授权
await token.approve(spender, 0);
```

**4. 重放攻击**

```javascript
// ❌ 无 nonce 的签名可被重放
const message = `Login to MyDApp at ${new Date().toISOString()}`;

// ✅ 使用唯一 nonce
const nonce = await fetchNonce(address);
const message = `Login to MyDApp\nNonce: ${nonce}`;
```

**5. 前端欺骗**

```javascript
// ✅ 验证合约地址
const VERIFIED_CONTRACTS = {
  mainnet: {
    USDT: '0xdAC17F958D2ee523a2206206994597C13D831ec7',
    USDC: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
  }
};

function isVerifiedContract(address, chainId) {
  const chainContracts = VERIFIED_CONTRACTS[chainId];
  return Object.values(chainContracts || {})
    .some(a => a.toLowerCase() === address.toLowerCase());
}

// ✅ 检查合约代码
async function isContract(address) {
  const code = await provider.getCode(address);
  return code !== '0x';
}
```

**6. 交易模拟**

```javascript
// ✅ 交易前模拟
async function simulateTransaction(tx) {
  try {
    await provider.estimateGas(tx);
    return { success: true };
  } catch (error) {
    return {
      success: false,
      error: error.reason || 'Transaction will fail'
    };
  }
}

// 使用 Tenderly 等服务进行详细模拟
async function simulateWithTenderly(tx) {
  const response = await fetch('https://api.tenderly.co/api/v1/simulate', {
    method: 'POST',
    headers: {
      'X-Access-Key': TENDERLY_API_KEY
    },
    body: JSON.stringify({
      network_id: '1',
      from: tx.from,
      to: tx.to,
      input: tx.data,
      value: tx.value
    })
  });

  return response.json();
}
```

---

### 25. 如何优化 DApp 的用户体验？

**答案：**

**1. 交易状态反馈**

```javascript
// 完整的交易状态管理
function useTransaction() {
  const [status, setStatus] = useState('idle');
  const [txHash, setTxHash] = useState(null);
  const [error, setError] = useState(null);

  const execute = async (contractCall) => {
    try {
      setStatus('confirming'); // 等待钱包确认
      setError(null);

      const tx = await contractCall();
      setTxHash(tx.hash);
      setStatus('pending'); // 等待链上确认

      const receipt = await tx.wait();

      if (receipt.status === 1) {
        setStatus('success');
      } else {
        setStatus('failed');
      }

      return receipt;
    } catch (err) {
      setError(err);
      setStatus('error');
      throw err;
    }
  };

  return { status, txHash, error, execute };
}

// 使用
function MintButton() {
  const { status, txHash, error, execute } = useTransaction();

  const handleMint = () => {
    execute(() => contract.mint(1, { value: price }));
  };

  return (
    <div>
      <button onClick={handleMint} disabled={status === 'confirming' || status === 'pending'}>
        {status === 'confirming' && '请在钱包中确认...'}
        {status === 'pending' && '交易处理中...'}
        {status === 'idle' && 'Mint NFT'}
      </button>

      {txHash && (
        <a href={`https://etherscan.io/tx/${txHash}`} target="_blank">
          查看交易
        </a>
      )}

      {status === 'success' && <p>Mint 成功！</p>}
      {error && <p>错误: {error.message}</p>}
    </div>
  );
}
```

**2. Gas 估算和展示**

```javascript
async function estimateAndShowGas(contractCall) {
  const provider = new ethers.BrowserProvider(window.ethereum);

  // 估算 Gas
  const gasEstimate = await contractCall.estimateGas();

  // 获取 Gas 价格
  const feeData = await provider.getFeeData();

  // 计算费用
  const gasCost = gasEstimate * feeData.gasPrice;
  const gasCostETH = ethers.formatEther(gasCost);

  // 获取 ETH 价格
  const ethPrice = await getETHPrice(); // 从 API 获取

  return {
    gasLimit: gasEstimate.toString(),
    gasPrice: ethers.formatUnits(feeData.gasPrice, 'gwei'),
    costETH: gasCostETH,
    costUSD: (parseFloat(gasCostETH) * ethPrice).toFixed(2)
  };
}
```

**3. 乐观更新**

```javascript
function useOptimisticUpdate() {
  const [items, setItems] = useState([]);

  const addItem = async (newItem) => {
    // 1. 乐观更新 UI
    const optimisticItem = { ...newItem, status: 'pending' };
    setItems(prev => [...prev, optimisticItem]);

    try {
      // 2. 执行链上操作
      const tx = await contract.addItem(newItem.id);
      await tx.wait();

      // 3. 确认成功
      setItems(prev =>
        prev.map(item =>
          item.id === newItem.id
            ? { ...item, status: 'confirmed' }
            : item
        )
      );
    } catch (error) {
      // 4. 回滚
      setItems(prev => prev.filter(item => item.id !== newItem.id));
      throw error;
    }
  };

  return { items, addItem };
}
```

**4. 离线支持**

```javascript
// 缓存链上数据
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 30000, // 30 秒内不重新获取
      cacheTime: 3600000, // 缓存 1 小时
    }
  }
});

// 使用 wagmi 的 useContractRead
function useTokenBalance(address) {
  return useContractRead({
    address: TOKEN_ADDRESS,
    abi: ERC20_ABI,
    functionName: 'balanceOf',
    args: [address],
    watch: true, // 自动轮询
    cacheTime: 30000
  });
}
```

---

## 常见工具与框架

### 26. Web3 前端开发常用的工具和库有哪些？

**答案：**

**核心库：**

| 库 | 用途 |
|-----|------|
| ethers.js | 以太坊交互 |
| wagmi | React Hooks |
| viem | 现代以太坊库 |
| web3.js | 以太坊交互（老牌） |

**钱包连接：**

| 库 | 用途 |
|-----|------|
| RainbowKit | 钱包 UI 组件 |
| Web3Modal | 多钱包连接 |
| ConnectKit | 钱包连接 UI |

**开发工具：**

| 工具 | 用途 |
|-----|------|
| Hardhat | 智能合约开发 |
| Foundry | 智能合约开发（Rust） |
| Remix | 在线 IDE |

**API 服务：**

| 服务 | 用途 |
|-----|------|
| Alchemy | 节点服务、NFT API |
| Infura | 节点服务 |
| Moralis | Web3 API |
| The Graph | 链上数据索引 |

```javascript
// 推荐的技术栈配置
// package.json
{
  "dependencies": {
    // 核心
    "ethers": "^6.x",
    "wagmi": "^1.x",
    "viem": "^1.x",

    // 钱包
    "@rainbow-me/rainbowkit": "^1.x",
    "@walletconnect/web3-provider": "^2.x",

    // React
    "react": "^18.x",
    "@tanstack/react-query": "^4.x",

    // UI
    "tailwindcss": "^3.x"
  },
  "devDependencies": {
    "typescript": "^5.x",
    "@types/react": "^18.x"
  }
}

// 项目结构
/*
src/
├── components/
│   ├── ConnectButton.tsx
│   ├── TransactionButton.tsx
│   └── NFTCard.tsx
├── hooks/
│   ├── useContract.ts
│   ├── useBalance.ts
│   └── useNFTs.ts
├── lib/
│   ├── wagmi.ts      # wagmi 配置
│   ├── contracts.ts  # 合约 ABI 和地址
│   └── utils.ts      # 工具函数
├── pages/
└── App.tsx
*/
```

---

### 27. 如何使用 wagmi 和 viem 进行开发？

**答案：**

```typescript
// lib/wagmi.ts - 配置
import { createConfig, configureChains } from 'wagmi';
import { mainnet, polygon, arbitrum } from 'wagmi/chains';
import { publicProvider } from 'wagmi/providers/public';
import { alchemyProvider } from 'wagmi/providers/alchemy';
import { getDefaultWallets } from '@rainbow-me/rainbowkit';

const { chains, publicClient, webSocketPublicClient } = configureChains(
  [mainnet, polygon, arbitrum],
  [
    alchemyProvider({ apiKey: process.env.ALCHEMY_API_KEY! }),
    publicProvider()
  ]
);

const { connectors } = getDefaultWallets({
  appName: 'My DApp',
  projectId: process.env.WALLETCONNECT_PROJECT_ID!,
  chains
});

export const config = createConfig({
  autoConnect: true,
  connectors,
  publicClient,
  webSocketPublicClient
});

export { chains };
```

```typescript
// hooks/useContract.ts
import { useContractRead, useContractWrite, usePrepareContractWrite, useWaitForTransaction } from 'wagmi';
import { parseEther, formatEther } from 'viem';

// 合约配置
const NFT_CONTRACT = {
  address: '0x...' as `0x${string}`,
  abi: [...] as const
};

// 读取合约
export function useNFTBalance(address?: `0x${string}`) {
  return useContractRead({
    ...NFT_CONTRACT,
    functionName: 'balanceOf',
    args: address ? [address] : undefined,
    enabled: !!address,
    watch: true
  });
}

// 写入合约（推荐模式）
export function useMint() {
  const { config } = usePrepareContractWrite({
    ...NFT_CONTRACT,
    functionName: 'mint',
    args: [1n],
    value: parseEther('0.1')
  });

  const { data, write, isLoading: isWriteLoading } = useContractWrite(config);

  const { isLoading: isConfirming, isSuccess } = useWaitForTransaction({
    hash: data?.hash
  });

  return {
    mint: write,
    isLoading: isWriteLoading || isConfirming,
    isSuccess,
    txHash: data?.hash
  };
}
```

```tsx
// components/MintButton.tsx
import { useAccount, useNetwork, useSwitchNetwork } from 'wagmi';
import { useMint, useNFTBalance } from '../hooks/useContract';

export function MintButton() {
  const { address, isConnected } = useAccount();
  const { chain } = useNetwork();
  const { switchNetwork } = useSwitchNetwork();

  const { data: balance } = useNFTBalance(address);
  const { mint, isLoading, isSuccess, txHash } = useMint();

  // 检查网络
  if (chain?.id !== 1) {
    return (
      <button onClick={() => switchNetwork?.(1)}>
        切换到以太坊主网
      </button>
    );
  }

  if (!isConnected) {
    return <ConnectButton />;
  }

  return (
    <div>
      <p>您持有: {balance?.toString() || 0} 个 NFT</p>

      <button
        onClick={() => mint?.()}
        disabled={!mint || isLoading}
      >
        {isLoading ? 'Minting...' : 'Mint NFT (0.1 ETH)'}
      </button>

      {isSuccess && (
        <p>
          成功！
          <a href={`https://etherscan.io/tx/${txHash}`}>
            查看交易
          </a>
        </p>
      )}
    </div>
  );
}
```

```tsx
// App.tsx
import { WagmiConfig } from 'wagmi';
import { RainbowKitProvider } from '@rainbow-me/rainbowkit';
import { config, chains } from './lib/wagmi';

import '@rainbow-me/rainbowkit/styles.css';

function App() {
  return (
    <WagmiConfig config={config}>
      <RainbowKitProvider chains={chains}>
        <MintButton />
      </RainbowKitProvider>
    </WagmiConfig>
  );
}
```

---

## The Graph 与数据索引

### 28. 什么是 The Graph？如何查询链上数据？

**答案：**

**The Graph：** 去中心化的区块链数据索引协议，使用 GraphQL 查询

```javascript
// 查询 Uniswap V3 数据
const UNISWAP_SUBGRAPH = 'https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3';

async function querySubgraph(query, variables = {}) {
  const response = await fetch(UNISWAP_SUBGRAPH, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ query, variables })
  });

  const { data, errors } = await response.json();

  if (errors) {
    throw new Error(errors[0].message);
  }

  return data;
}

// 查询 Token 信息
async function getTokenInfo(tokenAddress) {
  const query = `
    query GetToken($id: ID!) {
      token(id: $id) {
        id
        symbol
        name
        decimals
        totalSupply
        volumeUSD
        txCount
      }
    }
  `;

  const data = await querySubgraph(query, {
    id: tokenAddress.toLowerCase()
  });

  return data.token;
}

// 查询交易历史
async function getSwaps(userAddress, first = 10) {
  const query = `
    query GetSwaps($user: String!, $first: Int!) {
      swaps(
        where: { origin: $user }
        first: $first
        orderBy: timestamp
        orderDirection: desc
      ) {
        id
        timestamp
        token0 { symbol }
        token1 { symbol }
        amount0
        amount1
        amountUSD
      }
    }
  `;

  const data = await querySubgraph(query, {
    user: userAddress.toLowerCase(),
    first
  });

  return data.swaps;
}

// 使用 Apollo Client
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const client = new ApolloClient({
  uri: UNISWAP_SUBGRAPH,
  cache: new InMemoryCache()
});

// React Hook
function useTokenData(tokenAddress) {
  const { data, loading, error } = useQuery(
    gql`
      query GetToken($id: ID!) {
        token(id: $id) {
          symbol
          name
          volumeUSD
        }
      }
    `,
    { variables: { id: tokenAddress.toLowerCase() } }
  );

  return { token: data?.token, loading, error };
}
```

---

## 面试常见问题

### 29. 描述一个完整的 NFT Mint 流程

**答案：**

```
用户视角流程：
1. 连接钱包
2. 选择数量
3. 确认价格和 Gas 费
4. 在钱包中签名交易
5. 等待链上确认
6. 查看 Mint 结果

技术实现流程：
1. 检测钱包连接状态
2. 验证用户是否在正确网络
3. 检查合约状态（是否开售、剩余数量、价格）
4. 检查用户余额是否足够
5. 估算 Gas 费用
6. 调用合约 mint 函数
7. 监听交易状态
8. 解析事件获取 tokenId
9. 更新 UI 展示结果
```

```javascript
async function completeMintFlow(quantity) {
  const provider = new ethers.BrowserProvider(window.ethereum);

  // 1. 检查连接
  const accounts = await provider.listAccounts();
  if (accounts.length === 0) {
    throw new Error('请先连接钱包');
  }

  // 2. 检查网络
  const network = await provider.getNetwork();
  if (network.chainId !== 1n) {
    await switchToMainnet();
  }

  const signer = await provider.getSigner();
  const userAddress = await signer.getAddress();
  const contract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, signer);

  // 3. 检查合约状态
  const [isActive, totalSupply, maxSupply, mintPrice, userMinted, maxPerWallet] = await Promise.all([
    contract.saleIsActive(),
    contract.totalSupply(),
    contract.maxSupply(),
    contract.mintPrice(),
    contract.numberMinted(userAddress),
    contract.maxPerWallet()
  ]);

  if (!isActive) {
    throw new Error('销售未开始');
  }

  if (totalSupply + BigInt(quantity) > maxSupply) {
    throw new Error(`剩余数量不足，仅剩 ${maxSupply - totalSupply} 个`);
  }

  if (userMinted + BigInt(quantity) > maxPerWallet) {
    throw new Error(`超出每钱包限制，您还可以 mint ${maxPerWallet - userMinted} 个`);
  }

  // 4. 检查余额
  const totalCost = mintPrice * BigInt(quantity);
  const balance = await provider.getBalance(userAddress);

  // 估算 Gas
  const gasEstimate = await contract.mint.estimateGas(quantity, { value: totalCost });
  const feeData = await provider.getFeeData();
  const gasCost = gasEstimate * feeData.gasPrice;

  if (balance < totalCost + gasCost) {
    throw new Error(`余额不足，需要 ${ethers.formatEther(totalCost + gasCost)} ETH`);
  }

  // 5. 发送交易
  const tx = await contract.mint(quantity, {
    value: totalCost,
    gasLimit: gasEstimate * 120n / 100n // 增加 20% buffer
  });

  // 6. 等待确认
  const receipt = await tx.wait();

  // 7. 解析结果
  const mintedTokens = receipt.logs
    .filter(log => log.address.toLowerCase() === NFT_ADDRESS.toLowerCase())
    .map(log => {
      try {
        const parsed = contract.interface.parseLog(log);
        if (parsed.name === 'Transfer') {
          return parsed.args.tokenId.toString();
        }
      } catch {}
      return null;
    })
    .filter(Boolean);

  return {
    success: true,
    txHash: receipt.hash,
    tokenIds: mintedTokens,
    gasUsed: receipt.gasUsed.toString()
  };
}
```

---

### 30. Web3 前端开发者需要掌握哪些技能？

**答案：**

**核心技能：**

1. **区块链基础**
   - 理解区块链工作原理
   - 了解以太坊、EVM、Gas 机制
   - 熟悉常见代币标准（ERC-20、ERC-721、ERC-1155）

2. **Web3 库使用**
   - 熟练使用 ethers.js / viem
   - 掌握 wagmi React Hooks
   - 了解 web3.js

3. **钱包集成**
   - MetaMask 等钱包连接
   - WalletConnect 协议
   - 多钱包支持（RainbowKit/Web3Modal）

4. **智能合约交互**
   - 读取合约数据
   - 发送交易
   - 事件监听
   - 理解 ABI

5. **签名与安全**
   - 消息签名
   - EIP-712 类型化签名
   - 签名验证
   - 安全最佳实践

6. **前端基础**
   - React/Vue
   - TypeScript
   - 状态管理

**进阶技能：**

7. **多链支持**
   - L2 解决方案
   - 跨链桥
   - 多链数据聚合

8. **DeFi 知识**
   - DEX 交互
   - 流动性池
   - 借贷协议

9. **NFT 开发**
   - 元数据标准
   - IPFS 存储
   - 市场集成

10. **性能优化**
    - 数据缓存
    - 请求优化
    - 用户体验

**学习资源：**

- [Ethereum.org](https://ethereum.org/developers)
- [Alchemy University](https://university.alchemy.com)
- [CryptoZombies](https://cryptozombies.io)
- [Speedrun Ethereum](https://speedrunethereum.com)
- [wagmi 文档](https://wagmi.sh)
- [ethers.js 文档](https://docs.ethers.org)
