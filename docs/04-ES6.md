# ES6+ 面试题

## 变量声明

### 1. let、const 和 var 的区别？（详见 JavaScript 基础）

补充：**暂时性死区（TDZ）原理**

```javascript
// 编译阶段，let/const 声明会被提升，但不会初始化
// 从块作用域开始到变量声明之间，形成暂时性死区

let x = 'outer';

function foo() {
  console.log(x); // ReferenceError: Cannot access 'x' before initialization
  let x = 'inner';
}

// typeof 也会报错
typeof undeclaredVar; // undefined（未声明的变量）
typeof tdzVar;        // ReferenceError
let tdzVar;
```

---

## 解构赋值

### 2. 什么是解构赋值？有哪些用法？

**答案：**

**数组解构：**
```javascript
// 基本用法
const [a, b, c] = [1, 2, 3];

// 默认值
const [x = 1, y = 2] = [undefined, null];
// x = 1, y = null（只有 undefined 才会使用默认值）

// 交换变量
let a = 1, b = 2;
[a, b] = [b, a];

// 跳过元素
const [, , third] = [1, 2, 3]; // third = 3

// 剩余元素
const [first, ...rest] = [1, 2, 3, 4];
// first = 1, rest = [2, 3, 4]

// 嵌套解构
const [a, [b, c]] = [1, [2, 3]];
```

**对象解构：**
```javascript
// 基本用法
const { name, age } = { name: '张三', age: 18 };

// 重命名
const { name: userName } = { name: '张三' };
// userName = '张三'

// 默认值
const { name = '默认' } = {};

// 重命名 + 默认值
const { name: userName = '默认' } = {};

// 嵌套解构
const { address: { city } } = { address: { city: '北京' } };

// 剩余属性
const { a, ...rest } = { a: 1, b: 2, c: 3 };
// a = 1, rest = { b: 2, c: 3 }
```

**函数参数解构：**
```javascript
// 数组参数
function sum([a, b]) {
  return a + b;
}

// 对象参数
function greet({ name, age = 18 }) {
  return `${name}, ${age}`;
}

// 设置参数默认值
function request({ url, method = 'GET', data = {} } = {}) {
  // ...
}
```

---

## 字符串扩展

### 3. 模板字符串有哪些特性？

**答案：**

```javascript
const name = '张三';
const age = 18;

// 基本用法
const str = `我是 ${name}，今年 ${age} 岁`;

// 多行字符串
const html = `
  <div>
    <h1>${name}</h1>
  </div>
`;

// 表达式
const result = `1 + 2 = ${1 + 2}`;

// 嵌套模板
const isVip = true;
const msg = `用户状态: ${isVip ? `VIP 用户` : `普通用户`}`;

// 标签模板（Tagged Templates）
function highlight(strings, ...values) {
  return strings.reduce((result, str, i) => {
    const value = values[i] ? `<mark>${values[i]}</mark>` : '';
    return result + str + value;
  }, '');
}

const highlighted = highlight`Hello, ${name}! You are ${age} years old.`;
// 'Hello, <mark>张三</mark>! You are <mark>18</mark> years old.'
```

**新增字符串方法：**
```javascript
str.includes('hello');    // 是否包含
str.startsWith('hello');  // 是否以...开头
str.endsWith('world');    // 是否以...结尾
str.repeat(3);            // 重复 3 次
str.padStart(10, '0');    // 前补齐
str.padEnd(10, ' ');      // 后补齐
str.trimStart();          // 去除前空格
str.trimEnd();            // 去除后空格
str.replaceAll('a', 'b'); // 全部替换
str.at(-1);               // 支持负索引
```

---

## 函数扩展

### 4. 箭头函数有哪些特点？

**答案：**

```javascript
// 基本语法
const add = (a, b) => a + b;
const square = x => x * x;
const greet = () => 'hello';

// 返回对象需要括号
const getObj = () => ({ name: '张三' });
```

**特点：**

| 特性 | 箭头函数 | 普通函数 |
|------|----------|----------|
| this | 继承外层 | 动态绑定 |
| arguments | 没有 | 有 |
| prototype | 没有 | 有 |
| new 调用 | 不能 | 可以 |
| super | 没有 | 有 |
| yield | 不能用于 Generator | 可以 |

```javascript
// this 示例
const obj = {
  name: 'obj',
  regular() {
    setTimeout(function() {
      console.log(this.name); // undefined（this 指向 window）
    }, 100);
  },
  arrow() {
    setTimeout(() => {
      console.log(this.name); // 'obj'（继承 arrow 的 this）
    }, 100);
  }
};

// arguments 替代方案
const fn = (...args) => {
  console.log(args);
};

// 不能作为构造函数
const Person = (name) => {
  this.name = name;
};
new Person('张三'); // TypeError: Person is not a constructor
```

**什么时候不应该使用箭头函数：**
```javascript
// 1. 对象方法
const obj = {
  name: '张三',
  greet: () => {
    console.log(this.name); // undefined
  }
};

// 2. 原型方法
Person.prototype.sayHello = () => {
  console.log(this.name); // undefined
};

// 3. 构造函数

// 4. 需要动态 this 的场景（如事件监听）
button.addEventListener('click', () => {
  console.log(this); // window，而不是 button
});
```

---

### 5. 函数参数默认值和剩余参数

**答案：**

**默认参数：**
```javascript
// 基本用法
function greet(name = 'World') {
  return `Hello, ${name}!`;
}

// 默认参数可以是表达式
function getDate(date = new Date()) {
  return date;
}

// 默认参数可以引用其他参数
function add(a, b = a) {
  return a + b;
}

// 参数默认值影响 length
(function(a, b, c) {}).length;       // 3
(function(a, b, c = 1) {}).length;   // 2
(function(a, b = 1, c) {}).length;   // 1
```

**剩余参数（Rest Parameters）：**
```javascript
function sum(...numbers) {
  return numbers.reduce((a, b) => a + b, 0);
}

sum(1, 2, 3, 4); // 10

// 必须是最后一个参数
function fn(first, ...rest) {
  console.log(first, rest);
}
```

**展开运算符（Spread Operator）：**
```javascript
// 数组展开
const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5]; // [1, 2, 3, 4, 5]

// 函数调用
Math.max(...arr1); // 3

// 对象展开
const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1, c: 3 }; // { a: 1, b: 2, c: 3 }

// 复制数组/对象
const arrCopy = [...arr1];
const objCopy = { ...obj1 };
```

---

## 对象扩展

### 6. 对象的简写和新方法

**答案：**

**属性简写：**
```javascript
const name = '张三';
const age = 18;

// 属性简写
const person = { name, age };

// 方法简写
const obj = {
  greet() {
    return 'hello';
  },
  // 等价于
  // greet: function() { return 'hello'; }
};

// 计算属性名
const key = 'name';
const obj2 = {
  [key]: '张三',
  [`${key}2`]: '李四',
  ['say' + 'Hello']() {
    return 'hello';
  }
};
```

**Object 新方法：**
```javascript
// Object.is()
Object.is(NaN, NaN); // true（=== 返回 false）
Object.is(+0, -0);   // false（=== 返回 true）

// Object.assign()
const target = { a: 1 };
Object.assign(target, { b: 2 }, { c: 3 });
// target: { a: 1, b: 2, c: 3 }

// Object.keys/values/entries
const obj = { a: 1, b: 2 };
Object.keys(obj);    // ['a', 'b']
Object.values(obj);  // [1, 2]
Object.entries(obj); // [['a', 1], ['b', 2]]

// Object.fromEntries()
Object.fromEntries([['a', 1], ['b', 2]]); // { a: 1, b: 2 }

// Object.getOwnPropertyDescriptors()
Object.getOwnPropertyDescriptors(obj);
```

---

## 数组扩展

### 7. 数组的新方法和扩展

**答案：**

**Array.from()：**
```javascript
// 类数组转数组
Array.from(document.querySelectorAll('div'));
Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']

// 带映射函数
Array.from([1, 2, 3], x => x * 2); // [2, 4, 6]

// 生成序列
Array.from({ length: 5 }, (_, i) => i); // [0, 1, 2, 3, 4]
```

**Array.of()：**
```javascript
Array.of(1, 2, 3); // [1, 2, 3]
Array.of(3);       // [3]（与 Array(3) 不同，后者创建长度为 3 的空数组）
```

**实例方法：**
```javascript
const arr = [1, 2, 3, 4, 5];

// find / findIndex
arr.find(x => x > 3);      // 4
arr.findIndex(x => x > 3); // 3

// findLast / findLastIndex (ES2023)
arr.findLast(x => x > 3);      // 5
arr.findLastIndex(x => x > 3); // 4

// includes
arr.includes(3);     // true
arr.includes(3, 3);  // false（从索引 3 开始查找）

// flat / flatMap
[[1, 2], [3, 4]].flat();           // [1, 2, 3, 4]
[[1, [2, 3]], 4].flat(2);          // [1, 2, 3, 4]
[1, 2, 3].flatMap(x => [x, x * 2]); // [1, 2, 2, 4, 3, 6]

// at（支持负索引）
arr.at(-1);  // 5
arr.at(-2);  // 4

// fill
[1, 2, 3].fill(0);       // [0, 0, 0]
[1, 2, 3].fill(0, 1, 2); // [1, 0, 3]

// copyWithin
[1, 2, 3, 4, 5].copyWithin(0, 3); // [4, 5, 3, 4, 5]
```

**ES2023 新增（不改变原数组）：**
```javascript
const arr = [3, 1, 2];

arr.toSorted((a, b) => a - b); // [1, 2, 3]，原数组不变
arr.toReversed();              // [2, 1, 3]，原数组不变
arr.toSpliced(1, 1, 'a');      // [3, 'a', 2]，原数组不变
arr.with(0, 'new');            // ['new', 1, 2]，原数组不变
```

---

## Symbol

### 8. Symbol 是什么？有什么用？

**答案：**

Symbol 是 ES6 新增的原始数据类型，表示独一无二的值。

```javascript
// 创建 Symbol
const s1 = Symbol();
const s2 = Symbol('description');

// 每个 Symbol 都是唯一的
Symbol() === Symbol(); // false
Symbol('a') === Symbol('a'); // false

// 作为对象属性
const key = Symbol('myKey');
const obj = {
  [key]: 'value',
  name: '张三'
};

obj[key]; // 'value'

// Symbol 属性不会被常规遍历
Object.keys(obj);                 // ['name']
Object.getOwnPropertyNames(obj);  // ['name']
Object.getOwnPropertySymbols(obj); // [Symbol(myKey)]
Reflect.ownKeys(obj);             // ['name', Symbol(myKey)]
```

**全局 Symbol：**
```javascript
// Symbol.for() 创建全局 Symbol
const s1 = Symbol.for('shared');
const s2 = Symbol.for('shared');
s1 === s2; // true

// Symbol.keyFor() 获取全局 Symbol 的 key
Symbol.keyFor(s1); // 'shared'
```

**内置 Symbol：**
```javascript
// Symbol.iterator - 定义迭代器
const obj = {
  data: [1, 2, 3],
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.data.length) {
          return { value: this.data[index++], done: false };
        }
        return { done: true };
      }
    };
  }
};

for (const item of obj) {
  console.log(item); // 1, 2, 3
}

// Symbol.toStringTag - 自定义对象类型标签
class MyClass {
  get [Symbol.toStringTag]() {
    return 'MyClass';
  }
}
Object.prototype.toString.call(new MyClass()); // '[object MyClass]'

// Symbol.toPrimitive - 自定义类型转换
const obj2 = {
  [Symbol.toPrimitive](hint) {
    if (hint === 'number') return 42;
    if (hint === 'string') return 'hello';
    return true;
  }
};
+obj2;       // 42
`${obj2}`;   // 'hello'
obj2 + '';   // 'true'
```

---

## Set 和 Map

### 9. Set 和 Map 数据结构

**答案：**

**Set：**
```javascript
// 创建 Set
const set = new Set([1, 2, 3, 3]); // {1, 2, 3}

// 方法
set.add(4);      // 添加
set.delete(1);   // 删除
set.has(2);      // 判断
set.clear();     // 清空
set.size;        // 大小

// 遍历
set.forEach(value => console.log(value));
for (const value of set) { }
set.keys();
set.values();
set.entries();

// 数组去重
const unique = [...new Set([1, 2, 2, 3])];

// 交集、并集、差集
const a = new Set([1, 2, 3]);
const b = new Set([2, 3, 4]);

// 并集
const union = new Set([...a, ...b]); // {1, 2, 3, 4}

// 交集
const intersection = new Set([...a].filter(x => b.has(x))); // {2, 3}

// 差集
const difference = new Set([...a].filter(x => !b.has(x))); // {1}
```

**WeakSet：**
```javascript
// 只能存储对象引用，弱引用（不阻止垃圾回收）
const ws = new WeakSet();
const obj = { a: 1 };
ws.add(obj);
ws.has(obj); // true
ws.delete(obj);

// 不可遍历，没有 size 属性
// 用途：存储 DOM 节点，避免内存泄漏
```

**Map：**
```javascript
// 创建 Map
const map = new Map([
  ['name', '张三'],
  ['age', 18]
]);

// 方法
map.set('gender', '男');
map.get('name');    // '张三'
map.has('name');    // true
map.delete('age');
map.clear();
map.size;           // 大小

// 遍历
map.forEach((value, key) => console.log(key, value));
for (const [key, value] of map) { }
map.keys();
map.values();
map.entries();

// Map 可以使用任意类型作为键
const objKey = { id: 1 };
map.set(objKey, 'object key');

// Map 与 Object 互转
// Map -> Object
const obj = Object.fromEntries(map);

// Object -> Map
const map2 = new Map(Object.entries(obj));
```

**WeakMap：**
```javascript
// 键只能是对象，弱引用
const wm = new WeakMap();
const key = { a: 1 };
wm.set(key, 'value');
wm.get(key);
wm.has(key);
wm.delete(key);

// 不可遍历，没有 size 属性
// 用途：存储私有数据、关联 DOM 元素数据
const privateData = new WeakMap();
class Person {
  constructor(name) {
    privateData.set(this, { name });
  }
  getName() {
    return privateData.get(this).name;
  }
}
```

---

## Class 类

### 10. ES6 Class 的用法和特性

**答案：**

```javascript
// 基本定义
class Person {
  // 私有字段（ES2022）
  #privateField = 'private';

  // 静态属性
  static count = 0;

  // 静态私有字段
  static #privateStatic = 'static private';

  // 构造函数
  constructor(name, age) {
    this.name = name;
    this.age = age;
    Person.count++;
  }

  // 实例方法
  greet() {
    return `Hello, I'm ${this.name}`;
  }

  // 私有方法（ES2022）
  #privateMethod() {
    return this.#privateField;
  }

  // 静态方法
  static getCount() {
    return Person.count;
  }

  // getter
  get info() {
    return `${this.name}, ${this.age}`;
  }

  // setter
  set info(value) {
    [this.name, this.age] = value.split(',');
  }
}

// 使用
const p = new Person('张三', 18);
p.greet();      // 'Hello, I\'m 张三'
p.info;         // '张三, 18'
Person.getCount(); // 1
```

**继承：**
```javascript
class Student extends Person {
  constructor(name, age, grade) {
    super(name, age); // 必须先调用 super
    this.grade = grade;
  }

  // 重写方法
  greet() {
    return `${super.greet()}, I'm in grade ${this.grade}`;
  }

  // 静态方法也可以继承
  static getDescription() {
    return `${super.getCount()} students`;
  }
}
```

**类表达式：**
```javascript
const MyClass = class {
  // ...
};

// 具名类表达式
const MyClass2 = class ClassName {
  static getName() {
    return ClassName.name;
  }
};
```

**注意事项：**
```javascript
// 1. 类声明不会提升
new Foo(); // ReferenceError
class Foo {}

// 2. 类内部默认严格模式

// 3. 类的方法默认不可枚举
Object.keys(Person.prototype); // []

// 4. 必须使用 new 调用
Person(); // TypeError

// 5. 类的属性名可以是表达式
const methodName = 'sayHello';
class Foo {
  [methodName]() {}
}
```

---

## Iterator 和 Generator

### 11. 什么是迭代器和生成器？

**答案：**

**迭代器（Iterator）：**
```javascript
// 手动实现迭代器
function createIterator(array) {
  let index = 0;
  return {
    next() {
      if (index < array.length) {
        return { value: array[index++], done: false };
      }
      return { value: undefined, done: true };
    }
  };
}

const iterator = createIterator([1, 2, 3]);
iterator.next(); // { value: 1, done: false }
iterator.next(); // { value: 2, done: false }
iterator.next(); // { value: 3, done: false }
iterator.next(); // { value: undefined, done: true }

// 可迭代对象
const iterable = {
  [Symbol.iterator]() {
    let step = 0;
    return {
      next() {
        step++;
        if (step <= 3) {
          return { value: step, done: false };
        }
        return { done: true };
      }
    };
  }
};

for (const x of iterable) {
  console.log(x); // 1, 2, 3
}
```

**内置可迭代对象：**
- Array
- String
- Map
- Set
- arguments
- NodeList
- TypedArray

**生成器（Generator）：**
```javascript
// 基本语法
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const g = gen();
g.next(); // { value: 1, done: false }
g.next(); // { value: 2, done: false }
g.next(); // { value: 3, done: false }
g.next(); // { value: undefined, done: true }

// 生成器自动实现迭代器协议
for (const x of gen()) {
  console.log(x); // 1, 2, 3
}

// yield* 委托
function* gen2() {
  yield* [1, 2];
  yield* gen();
}

// 传值
function* gen3() {
  const a = yield 1;
  const b = yield a + 2;
  return a + b;
}

const g3 = gen3();
g3.next();    // { value: 1, done: false }
g3.next(10);  // { value: 12, done: false }，a = 10
g3.next(20);  // { value: 30, done: true }，b = 20

// 异步应用（co 库原理）
function* fetchData() {
  const user = yield fetch('/api/user');
  const posts = yield fetch(`/api/posts/${user.id}`);
  return posts;
}
```

---

## Proxy 和 Reflect

### 12. Proxy 和 Reflect 的用法

**答案：**

**Proxy 基本用法：**
```javascript
const target = { name: '张三', age: 18 };

const proxy = new Proxy(target, {
  // 拦截读取属性
  get(target, property, receiver) {
    console.log(`读取 ${property}`);
    return Reflect.get(target, property, receiver);
  },

  // 拦截设置属性
  set(target, property, value, receiver) {
    console.log(`设置 ${property} = ${value}`);
    return Reflect.set(target, property, value, receiver);
  },

  // 拦截 in 操作符
  has(target, property) {
    return property in target;
  },

  // 拦截 delete
  deleteProperty(target, property) {
    return delete target[property];
  },

  // 拦截 Object.keys 等
  ownKeys(target) {
    return Reflect.ownKeys(target);
  },

  // 拦截函数调用
  apply(target, thisArg, args) {
    return target.apply(thisArg, args);
  },

  // 拦截 new
  construct(target, args) {
    return new target(...args);
  }
});
```

**响应式数据实现（Vue 3 原理）：**
```javascript
function reactive(obj) {
  return new Proxy(obj, {
    get(target, key, receiver) {
      const result = Reflect.get(target, key, receiver);
      console.log('track:', key); // 依赖收集
      // 深层响应式
      if (typeof result === 'object' && result !== null) {
        return reactive(result);
      }
      return result;
    },

    set(target, key, value, receiver) {
      const result = Reflect.set(target, key, value, receiver);
      console.log('trigger:', key); // 触发更新
      return result;
    },

    deleteProperty(target, key) {
      const result = Reflect.deleteProperty(target, key);
      console.log('trigger delete:', key);
      return result;
    }
  });
}

const state = reactive({ count: 0, nested: { value: 1 } });
state.count++;        // trigger: count
state.nested.value++; // track: nested, trigger: value
```

**Reflect 的作用：**
```javascript
// 1. 操作对象的统一 API
Reflect.get(obj, 'name');
Reflect.set(obj, 'name', '李四');
Reflect.has(obj, 'name');
Reflect.deleteProperty(obj, 'name');
Reflect.ownKeys(obj);
Reflect.defineProperty(obj, 'age', { value: 20 });
Reflect.getPrototypeOf(obj);
Reflect.setPrototypeOf(obj, proto);

// 2. 操作结果返回布尔值（而不是抛出异常）
if (Reflect.defineProperty(obj, 'name', desc)) {
  // 成功
} else {
  // 失败
}

// 3. 在 Proxy 中配合使用，保证 this 正确
const proxy = new Proxy(obj, {
  get(target, key, receiver) {
    // receiver 是 proxy 本身，保证 getter 中 this 正确
    return Reflect.get(target, key, receiver);
  }
});
```

---

## 模块化

### 13. ES6 模块化和 CommonJS 的区别

**答案：**

**ES6 模块（ESM）：**
```javascript
// 导出
export const name = '张三';
export function greet() {}
export class Person {}

// 默认导出
export default function() {}

// 重命名导出
export { name as userName };

// 导入
import { name, greet } from './module.js';
import Person from './module.js';
import * as module from './module.js';

// 重命名导入
import { name as userName } from './module.js';

// 动态导入
const module = await import('./module.js');
```

**CommonJS：**
```javascript
// 导出
module.exports = { name: '张三' };
exports.name = '张三';

// 导入
const module = require('./module');
const { name } = require('./module');
```

**区别：**

| 特性 | ES6 Module | CommonJS |
|------|------------|----------|
| 加载时机 | 编译时（静态） | 运行时（动态） |
| 输出 | 值的引用 | 值的拷贝 |
| 执行 | 模块作用域 | 模块作用域 |
| 循环引用 | 支持（但需注意） | 支持 |
| this | undefined | module.exports |
| 动态导入 | import() | require() |
| Tree-shaking | 支持 | 不支持 |

```javascript
// ES6 Module - 值的引用
// a.js
export let count = 0;
export function increment() { count++; }

// b.js
import { count, increment } from './a.js';
console.log(count); // 0
increment();
console.log(count); // 1（值已更新）

// CommonJS - 值的拷贝
// a.js
let count = 0;
module.exports = { count, increment: () => count++ };

// b.js
const { count, increment } = require('./a');
console.log(count); // 0
increment();
console.log(count); // 0（仍是原值）
```

---

## 新增数据结构和方法

### 14. ES2020+ 新特性

**答案：**

**可选链操作符（?.）：**
```javascript
const user = { address: { city: '北京' } };

// 旧写法
const city = user && user.address && user.address.city;

// 新写法
const city = user?.address?.city;

// 数组
arr?.[0];

// 函数调用
fn?.();

// 结合空值合并
const city = user?.address?.city ?? '未知';
```

**空值合并操作符（??）：**
```javascript
// || 的问题：0、''、false 被视为假值
const count = 0 || 10;  // 10
const name = '' || '默认'; // '默认'

// ?? 只在 null/undefined 时使用默认值
const count = 0 ?? 10;  // 0
const name = '' ?? '默认'; // ''
const value = null ?? '默认'; // '默认'
```

**BigInt：**
```javascript
const big = 9007199254740991n;
const big2 = BigInt(9007199254740991);

// 运算
big + 1n;  // 9007199254740992n
big * 2n;  // 18014398509481982n

// 不能与普通数字混合运算
big + 1; // TypeError

// 比较
big > 100; // true
big === 9007199254740991; // false（类型不同）
big == 9007199254740991;  // true
```

**Promise.allSettled / Promise.any：**
```javascript
// allSettled - 等待所有 promise 完成
const results = await Promise.allSettled([
  Promise.resolve(1),
  Promise.reject('error'),
  Promise.resolve(3)
]);
// [
//   { status: 'fulfilled', value: 1 },
//   { status: 'rejected', reason: 'error' },
//   { status: 'fulfilled', value: 3 }
// ]

// any - 返回第一个成功的
const first = await Promise.any([
  Promise.reject('error1'),
  Promise.resolve('success'),
  Promise.reject('error2')
]);
// 'success'
```

**globalThis：**
```javascript
// 统一的全局对象访问
globalThis.setTimeout === window.setTimeout; // 浏览器
globalThis.setTimeout === global.setTimeout; // Node.js
```

**逻辑赋值运算符（ES2021）：**
```javascript
// ||=
a ||= b; // a = a || b

// &&=
a &&= b; // a = a && b

// ??=
a ??= b; // a = a ?? b

// 实际应用
obj.name ??= '默认名称';
arr ||= [];
```

**数字分隔符：**
```javascript
const billion = 1_000_000_000;
const binary = 0b1010_0001;
const hex = 0xFF_EC_DE_5E;
```

**String.prototype.replaceAll：**
```javascript
'aabbcc'.replaceAll('a', 'x'); // 'xxbbcc'
// 之前需要用正则
'aabbcc'.replace(/a/g, 'x');
```

**WeakRef 和 FinalizationRegistry（ES2021）：**
```javascript
// WeakRef - 弱引用
let obj = { name: '张三' };
const weakRef = new WeakRef(obj);
obj = null;
// 之后 weakRef.deref() 可能返回 undefined

// FinalizationRegistry - 垃圾回收回调
const registry = new FinalizationRegistry((heldValue) => {
  console.log(`${heldValue} 被回收了`);
});

let obj2 = { name: '李四' };
registry.register(obj2, '李四的数据');
obj2 = null;
// 当 obj2 被垃圾回收时，会打印 "李四的数据 被回收了"
```

**Array.prototype.at（ES2022）：**
```javascript
const arr = [1, 2, 3, 4, 5];
arr.at(-1);  // 5
arr.at(-2);  // 4

const str = 'hello';
str.at(-1); // 'o'
```

**Object.hasOwn（ES2022）：**
```javascript
const obj = { name: '张三' };

// 旧写法
obj.hasOwnProperty('name'); // true

// 新写法（推荐）
Object.hasOwn(obj, 'name'); // true

// 区别：Object.hasOwn 不受原型链影响
const obj2 = Object.create(null);
obj2.name = '李四';
obj2.hasOwnProperty('name'); // TypeError
Object.hasOwn(obj2, 'name'); // true
```

**类私有字段和方法（ES2022）：**
```javascript
class Person {
  #name;
  #age = 18;

  constructor(name) {
    this.#name = name;
  }

  #privateMethod() {
    return this.#name;
  }

  getName() {
    return this.#privateMethod();
  }

  static #privateStatic = 'static';
  static getPrivateStatic() {
    return Person.#privateStatic;
  }
}
```

**顶层 await（ES2022）：**
```javascript
// 在模块顶层使用 await
const response = await fetch('/api/data');
const data = await response.json();

export { data };
```
